# 程式碼風格與格式化規範

## 決議：統一的程式碼品質標準

### ESLint 配置

```json
{
  "extends": [
    "@typescript-eslint/recommended",
    "react-hooks/recommended", 
    "react/recommended"
  ],
  "rules": {
    "no-unused-vars": "error",
    "consistent-naming": "error",
    "explicit-function-return-type": "warn"
  }
}
```

### Prettier 配置

```json
{
  "semi": true,
  "trailingComma": "es5", 
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false
}
```

### TypeScript 嚴格模式

```json
{
  "strict": true,
  "noImplicitAny": true,
  "strictNullChecks": true
}
```

### 命名規範

- **檔案：** kebab-case (`user-profile.tsx`)
- **元件：** PascalCase (`UserProfile`)
- **函數：** camelCase (`getUserData`)
- **常數：** UPPER_SNAKE_CASE (`API_BASE_URL`)
- **型別/介面：** PascalCase (`UserData`, `IUserData`)

### 程式碼組織原則

#### Import 順序
```typescript
// 1. 第三方庫
import React from 'react';
import { Button } from 'antd';

// 2. 內部模組
import { useAppSelector } from '@/hooks';
import { UserService } from '@/services';

// 3. 相對路徑
import './Component.scss';
```

#### 函數定義風格
```typescript
// 優先使用箭頭函數
const UserProfile: React.FC<UserProfileProps> = ({ user, onUpdate }) => {
  // 實作內容
};

// 複雜邏輯使用命名函數
function calculateComplexData(input: ComplexInput): ComplexOutput {
  // 複雜邏輯實作
}
```

#### 型別定義規範
```typescript
// 介面定義
interface UserData {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
}

// Props 型別
interface UserProfileProps {
  user: UserData;
  isEditable?: boolean;
  onUpdate?: (user: UserData) => void;
}
```

### 注釋規範

#### JSDoc 註解
```typescript
/**
 * 計算使用者年齡
 * @param birthDate 出生日期
 * @returns 年齡（歲）
 */
function calculateAge(birthDate: Date): number {
  const today = new Date();
  const age = today.getFullYear() - birthDate.getFullYear();
  return age;
}
```

#### 程式碼註解
```typescript
// TODO: 實作快取機制
// FIXME: 修復記憶體洩漏問題
// NOTE: 此處邏輯與後端API密切相關
```

### 規範遵循原則

#### 規範至上原則 (Specification First)
- **核心理念：** 規範文件是專案開發的絕對基準
- **嚴格執行：** 開發工作必須完全按照規範文件執行
- **禁止行為：** 不允許任何超出規範的實作或基於個人判斷的修改
- **權威層級：** 規範文件 > 個人經驗 > 技術最佳實踐 > 行業慣例

#### 創意分離原則 (Innovation Separation)
- **當下執行：** 只實作規範內容，不得自主擴展
- **創意記錄：** 額外想法必須記錄到專用文件
- **未來參考：** 作為下一階段規劃的輸入資料
- **流程分明：** 創意發想與實作執行完全分離

### 禁止的開發模式

#### 禁止的思維模式
- ❌ "這樣設計更合理，我來改進一下"
- ❌ "規範這裡不完善，我補充一些功能"
- ❌ "按照最佳實踐，應該這樣做"
- ❌ "這個邊界值看起來不對，我調整一下"

#### 禁止的實作模式
- ❌ 修改規範中的數值限制
- ❌ 增加規範中未提及的驗證邏輯
- ❌ 實作規範中未定義的功能
- ❌ 基於"用戶友好"考量修改規範

### 規範符合性檢查清單

**日常自檢清單：**
- [ ] 實作功能是否在規範定義範圍內？
- [ ] 數值限制是否嚴格按照規範設定？
- [ ] 驗證邏輯是否完全符合規範要求？
- [ ] 是否有任何超出規範的"改進"？
- [ ] 創意想法是否已分離記錄？

**代碼審查重點：**
- 規範文件引用：每個實作都應能對應到具體規範條目
- 邊界值驗證：確保所有邊界值都按規範設定
- 功能範圍檢查：確保沒有實作規範外功能
- 創意分離檢查：確保沒有私自增加的功能

### 創意想法管理

**創意記錄格式：**
```markdown
## 創意想法 #001
- **模組：** [相關模組名稱]
- **想法類型：** [功能增強/效能優化/用戶體驗等]
- **具體描述：** [詳細描述創意想法]
- **觸發原因：** [什麼情況下產生此想法]
- **潛在價值：** [預估的價值與好處]
- **實作複雜度：** [高/中/低]
- **記錄日期：** [記錄日期]
- **狀態：** 待評估
```

### 品質檢查規則

- **ESLint：** 0 錯誤，警告不超過 5 個
- **TypeScript：** 嚴格模式，0 型別錯誤
- **Prettier：** 自動格式化，無手動調整
- **Import：** 無未使用的 import
- **變數：** 無未使用的變數定義
- **規範符合性：** 100% 規範覆蓋率，零超範圍功能