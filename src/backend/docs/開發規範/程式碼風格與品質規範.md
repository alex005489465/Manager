# 程式碼風格與品質規範

## 📋 文件目的

本文件定義後端專案的程式碼風格標準、品質要求和開發工具使用規範，確保程式碼品質一致性。

## ☕ Java編碼標準

### 採用標準：Google Java Style Guide

**選擇理由：**
- 業界廣泛採用，規範完整且明確
- 工具支援完善（Checkstyle、Spotless、IDE插件）
- 與@Spec標註機制完全相容
- 減少程式碼風格討論，提高開發效率
- 社群資源豐富，學習成本低

### 核心規範要點

**命名規範：**
- 類別名使用 PascalCase：`RecipeService`
- 方法名使用 camelCase：`createRecipe()`
- 常數使用 UPPER_SNAKE_CASE：`MAX_RECIPE_COUNT`
- 包名使用小寫：`recipe.service`

**格式規範：**
- 縮排使用2個空格
- 行長度限制100字元
- import語句按組織排序
- 大括號使用Kernighan and Ritchie風格

## 🔧 Lombok使用規範

### 建議使用的註解

**✅ 推薦使用：**
- `@Data` - Entity類的getter/setter，減少樣板程式碼
- `@Builder` - 建構者模式，特別適合DTO物件
- `@Slf4j` - 日誌記錄，與Spring Boot完美整合
- `@RequiredArgsConstructor` - Service層依賴注入，替代@Autowired

**使用範例：**
```java
@Entity
@Table(name = "recipes") // @Spec: database-design.md:67
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Recipe {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id; // @Spec: model-validation.md:23
    
    @Column(nullable = false)
    @NotBlank // @Spec: model-validation.md:24
    private String name;
}

@Service
@RequiredArgsConstructor
@Slf4j
public class RecipeService {
    private final RecipeRepository recipeRepository;
    
    // 自動注入，無需@Autowired
}
```

### 謹慎使用的註解

**⚠️ 謹慎使用：**
- `@AllArgsConstructor` - 可能與Bean Validation註解產生衝突
- `@NoArgsConstructor` - JPA實體需要，但要確保不影響驗證邏輯

### 避免使用的註解

**❌ 避免使用：**
- `@SneakyThrows` - 隱藏重要的異常處理邏輯，違反明確性原則
- `@Cleanup` - 與Spring框架的資源管理機制可能產生衝突

## 🚨 異常處理策略

### 統一異常處理架構

**Global Exception Handler：**
```java
/**
 * 全域異常處理器
 * @Spec: api-design.md:error-handling - 錯誤回應格式標準
 */
@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    /**
     * 業務異常處理
     * @Spec: api-design.md:business-error - 業務錯誤回應格式
     */
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiResponse> handleBusinessException(BusinessException e) {
        log.warn("業務異常: code={}, message={}", e.getCode(), e.getMessage());
        return ResponseEntity.ok(ApiResponse.error(e.getCode(), e.getMessage()));
    }
    
    /**
     * 參數驗證異常處理
     * @Spec: api-design.md:validation-error - 驗證錯誤回應格式
     */
    @ExceptionHandler(MethodArgumentNotValidException.class) 
    public ResponseEntity<ApiResponse> handleValidationException(MethodArgumentNotValidException e) {
        String errorMessage = e.getBindingResult()
            .getFieldErrors()
            .stream()
            .map(FieldError::getDefaultMessage)
            .collect(Collectors.joining(", "));
            
        log.warn("參數驗證失敗: {}", errorMessage);
        return ResponseEntity.ok(ApiResponse.error("VALIDATION_ERROR", errorMessage));
    }
    
    /**
     * 系統異常處理
     * @Spec: api-design.md:system-error - 系統錯誤回應格式
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse> handleSystemException(Exception e) {
        log.error("系統異常", e);
        return ResponseEntity.ok(ApiResponse.error("SYSTEM_ERROR", "系統內部錯誤"));
    }
}
```

### 異常處理原則

**重要規範：**
- **HTTP狀態碼統一為200** - 完全遵循API設計文件規範
- **錯誤資訊在ApiResponse的error欄位中** - 保持回應格式一致
- **異常訊息使用設計文件中的精確用詞** - 確保與前端約定一致
- **業務異常需標註對應的設計文件來源** - 維持可追溯性

**自定義業務異常：**
```java
/**
 * 業務異常基類
 * @Spec: api-design.md:error-codes - 錯誤碼定義標準
 */
public class BusinessException extends RuntimeException {
    private final String code;
    
    public BusinessException(String code, String message) {
        super(message);
        this.code = code;
    }
    
    // getter methods...
}
```

## 📝 日誌記錄規範

### 日誌等級使用策略

**日誌等級定義：**
- **ERROR：** 系統錯誤，需要立即關注和處理
- **WARN：** 業務異常或潛在問題，需要關注但不影響系統運行
- **INFO：** 重要業務操作記錄（創建、更新、刪除），用於審計追蹤
- **DEBUG：** 詳細執行流程，僅在開發和測試環境使用

### 關鍵記錄點實施

**Service層日誌範例：**
```java
@Slf4j
@Service
@RequiredArgsConstructor
public class RecipeService {
    
    private final RecipeRepository recipeRepository;
    
    /**
     * 創建配方
     * @Spec: user-flow.md:create-recipe - 創建配方完整流程
     */
    public Recipe createRecipe(CreateRecipeRequest request) {
        log.info("創建配方開始: name={}", request.getName()); // @Spec: user-flow.md:102
        
        try {
            // 參數驗證 @Spec: model-validation.md:recipe-validation
            validateCreateRequest(request);
            
            // 業務邏輯處理 @Spec: user-flow.md:108-112
            Recipe recipe = Recipe.builder()
                .name(request.getName())
                .description(request.getDescription())
                .build();
            
            Recipe savedRecipe = recipeRepository.save(recipe);
            log.info("創建配方成功: id={}, name={}", savedRecipe.getId(), savedRecipe.getName());
            
            return savedRecipe;
            
        } catch (ValidationException e) {
            log.warn("創建配方驗證失敗: name={}, error={}", request.getName(), e.getMessage());
            throw new BusinessException("RECIPE_VALIDATION_FAILED", e.getMessage());
        } catch (Exception e) {
            log.error("創建配方系統異常: name={}", request.getName(), e);
            throw new BusinessException("RECIPE_CREATE_FAILED", "配方創建失敗");
        }
    }
    
    private void validateCreateRequest(CreateRecipeRequest request) {
        // @Spec: model-validation.md:30-35 - 配方創建驗證規則
        if (request.getName().trim().isEmpty()) {
            throw new ValidationException("配方名稱不能為空");
        }
        
        if (request.getName().length() > 100) {
            throw new ValidationException("配方名稱不能超過100個字元");
        }
    }
}
```

**Controller層日誌範例：**
```java
@RestController
@RequestMapping("/api/recipe")
@RequiredArgsConstructor
@Slf4j
public class RecipeController {
    
    private final RecipeService recipeService;
    
    /**
     * 創建配方API
     * @Spec: api-design.md:create-recipe - 創建配方API完整規格
     */
    @PostMapping("/create") // @Spec: api-design.md:45
    public ResponseEntity<ApiResponse> createRecipe(
        @RequestBody @Valid CreateRecipeRequest request // @Spec: api-design.md:53-58
    ) {
        log.debug("收到創建配方請求: {}", request);
        
        Recipe recipe = recipeService.createRecipe(request);
        
        log.debug("創建配方API回應: id={}", recipe.getId());
        return ResponseEntity.ok(ApiResponse.success(recipe)); // @Spec: api-design.md:59-65
    }
}
```

### 日誌配置建議

**logback-spring.xml配置：**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- 開發環境配置 -->
    <springProfile name="dev">
        <root level="DEBUG">
            <appender-ref ref="CONSOLE"/>
        </root>
    </springProfile>
    
    <!-- 生產環境配置 -->
    <springProfile name="prod">
        <root level="INFO">
            <appender-ref ref="FILE"/>
        </root>
    </springProfile>
    
    <!-- 業務日誌單獨記錄 -->
    <logger name="com.petworkshop.service" level="INFO" additivity="false">
        <appender-ref ref="BUSINESS_LOG"/>
    </logger>
</configuration>
```

## 📊 程式碼品質檢查

### 靜態程式碼分析

**工具整合：**
- **Checkstyle** - Google Java Style Guide規範檢查
- **SpotBugs** - 潛在問題和錯誤檢測
- **PMD** - 程式碼品質和潛在問題分析
- **SonarQube** - 綜合程式碼品質平台

**Maven配置範例：**
```xml
<plugin>
    <groupId>com.github.spotbugs</groupId>
    <artifactId>spotbugs-maven-plugin</artifactId>
    <version>4.7.3</version>
    <configuration>
        <effort>Max</effort>
        <threshold>Low</threshold>
    </configuration>
</plugin>

<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-checkstyle-plugin</artifactId>
    <version>3.2.0</version>
    <configuration>
        <configLocation>google_checks.xml</configLocation>
    </configuration>
</plugin>
```

### 程式碼審查標準

**審查重點：**
1. **設計文件符合性** - 每個實現都有對應的@Spec標註
2. **異常處理完整性** - 所有可能的異常都有適當處理
3. **日誌記錄充分性** - 關鍵業務操作都有日誌記錄
4. **程式碼風格一致性** - 符合Google Java Style Guide
5. **Lombok使用規範性** - 按照規範使用註解

## 🎯 開發工具配置

### IDE配置建議

**IntelliJ IDEA：**
- 安裝Google Java Format插件
- 配置Checkstyle插件使用google_checks.xml
- 啟用Lombok插件和註解處理
- 配置檔案模板包含@Spec標註格式

**VS Code：**
- 安裝Extension Pack for Java
- 配置java.format.settings.url指向Google Style
- 啟用Checkstyle和SpotBugs擴充套件

### 建構工具配置

**Maven設定：**
```xml
<properties>
    <java.version>21</java.version>
    <maven.compiler.source>21</maven.compiler.source>
    <maven.compiler.target>21</maven.compiler.target>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
</properties>

<!-- 程式碼格式化插件 -->
<plugin>
    <groupId>com.diffplug.spotless</groupId>
    <artifactId>spotless-maven-plugin</artifactId>
    <version>2.40.0</version>
    <configuration>
        <java>
            <googleJavaFormat/>
        </java>
    </configuration>
</plugin>
```

## 📋 品質檢查清單

### 日常開發檢查

**提交前檢查：**
- [ ] 所有程式碼都有對應的@Spec標註
- [ ] 遵循Google Java Style Guide格式規範
- [ ] Lombok註解使用符合規範要求
- [ ] 異常處理完整且訊息準確
- [ ] 重要操作都有適當的日誌記錄
- [ ] 靜態程式碼分析工具檢查通過

**程式碼審查檢查：**
- [ ] 設計文件引用準確且完整
- [ ] 業務邏輯實現符合規範要求
- [ ] 異常處理策略正確執行
- [ ] 日誌記錄等級和內容適當
- [ ] 程式碼結構清晰且可維護

---

**版本：** v1.0.0  
**建立日期：** 2025-09-07  
**狀態：** ✅ 程式碼風格與品質規範制定完成  
**適用範圍：** 所有後端開發工作  
**維護責任：** 後端開發團隊